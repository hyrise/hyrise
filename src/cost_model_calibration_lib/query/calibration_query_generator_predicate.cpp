#include "calibration_query_generator_predicate.hpp"

#include <random>

#include "constant_mappings.hpp"
#include "expression/expression_functional.hpp"
#include "expression/expression_utils.hpp"
#include "logical_query_plan/stored_table_node.hpp"
#include "logical_query_plan/validate_node.hpp"
#include "storage/storage_manager.hpp"

using namespace opossum::expression_functional;  // NOLINT

namespace opossum {

const std::vector<CalibrationQueryGeneratorPredicateConfiguration>
CalibrationQueryGeneratorPredicate::generate_predicate_permutations(
    const std::vector<std::pair<std::string, size_t>>& tables, const CalibrationConfiguration& configuration) {
  std::vector<CalibrationQueryGeneratorPredicateConfiguration> output{};

  // Generating all combinations
  for (const auto& data_type : configuration.data_types) {
    for (const auto& first_encoding : configuration.encodings) {
      for (const auto& second_encoding : configuration.encodings) {
        for (const auto& third_encoding : configuration.encodings) {
          for (const auto& selectivity : configuration.selectivities) {
            for (const auto& table : tables) {
              output.push_back({table.first, data_type, first_encoding, second_encoding, third_encoding, selectivity,
                                false, table.second});
              output.push_back({table.first, data_type, first_encoding, second_encoding, third_encoding, selectivity,
                                true, table.second});
            }
          }
        }
      }
    }
  }

  std::cout << "Generated " << output.size() << " Permutations for Predicates" << std::endl;
  return output;
}

/**
 * Generates a list of predicates that are generated by the predicate_generator,
 * e.g., an IndexScan-based and a TableScan-based variant,
 * but also permutations for different secondary columns in cases with column-to-columns scans.
*/
const std::vector<std::shared_ptr<PredicateNode>> CalibrationQueryGeneratorPredicate::generate_predicates(
    const PredicateGeneratorFunctor& predicate_generator,
    const std::vector<CalibrationColumnSpecification>& column_definitions,
    const std::shared_ptr<StoredTableNode>& table, const CalibrationQueryGeneratorPredicateConfiguration& configuration,
    const bool generate_index_scan) {
  auto predicate = predicate_generator({table, column_definitions, configuration});

  // TODO(Sven): add test for this case
  if (!predicate) {
    return {};
  }

  std::vector<ScanType> scan_types = {ScanType::TableScan, ScanType ::IndexScan};
  std::vector<std::shared_ptr<PredicateNode>> permutated_predicate_nodes{};

  for (const auto& scan_type : scan_types) {
    // IndexScans support less options than TableScans.. let's filter here
    if (scan_type == ScanType::IndexScan) {
      if (!generate_index_scan) continue;

      auto column_expression_count = 0;
      visit_expression(predicate, [&](const auto& sub_expression) {
        if (sub_expression->type == ExpressionType::LQPColumn) {
          column_expression_count += 1;
        }

        return ExpressionVisitation::VisitArguments;
      });

      // IndexScan neither works on ReferenceSegments nor handles multiple columns in B-Tree
      if (configuration.reference_column || column_expression_count > 1) continue;

      //      if (predicate->type != ExpressionType::Predicate) {
      //        std::cout << "Is this really supported? IndexScan with ExpressionType::"
      //                  << expression_type_to_string.at(predicate->type) << std::endl;
      //      }

      if (predicate->type == ExpressionType::Predicate) {
        const auto abstract_predicate_expression = std::dynamic_pointer_cast<AbstractPredicateExpression>(predicate);
        // IndexScans do not support Like or NotLike predicates
        const auto predicate_condition = abstract_predicate_expression->predicate_condition;
        if (predicate_condition == PredicateCondition::Like || predicate_condition == PredicateCondition::NotLike) {
          continue;
        }
      }
    }
    const auto predicate_node = PredicateNode::make(predicate);
    predicate_node->scan_type = scan_type;
    permutated_predicate_nodes.push_back(predicate_node);
  }

  return permutated_predicate_nodes;
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_between_value_value(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;
  const auto table = generator_configuration.table;

  const auto scan_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!scan_column_configuration) {
    return {};
  }

  const auto scan_column = _generate_column_expression(table, *scan_column_configuration);
  const auto first_value = _generate_value_expression(calibration_config.data_type, calibration_config.selectivity);
  const auto second_value = _generate_value_expression(calibration_config.data_type, 0.0f);

  if (first_value->value < second_value->value) {
    return between_(scan_column, first_value, second_value);
  }
  return between_(scan_column, second_value, first_value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_between_column_column(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;
  const auto table = generator_configuration.table;

  auto remaining_columns = generator_configuration.column_definitions;

  const auto scan_column_configuration = _find_column_for_configuration(remaining_columns, calibration_config.data_type,
                                                                        calibration_config.first_encoding_type);

  remaining_columns.erase(std::remove(remaining_columns.begin(), remaining_columns.end(), scan_column_configuration),
                          remaining_columns.end());

  const auto first_column_configuration = _find_column_for_configuration(
      remaining_columns, calibration_config.data_type, calibration_config.second_encoding_type);

  remaining_columns.erase(std::remove(remaining_columns.begin(), remaining_columns.end(), first_column_configuration),
                          remaining_columns.end());

  const auto second_column_configuration = _find_column_for_configuration(
      remaining_columns, calibration_config.data_type, calibration_config.third_encoding_type);

  if (!scan_column_configuration || !first_column_configuration || !second_column_configuration) {
    return {};
  }

  const auto scan_column = _generate_column_expression(table, *scan_column_configuration);
  const auto first_value = _generate_column_expression(table, *first_column_configuration);
  const auto second_value = _generate_column_expression(table, *second_column_configuration);

  return between_(scan_column, first_value, second_value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_column_value(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  const auto table = generator_configuration.table;
  const auto filter_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!filter_column_configuration) {
    return {};
  }

  const auto filter_column = _generate_column_expression(table, *filter_column_configuration);
  const auto value = _generate_value_expression(calibration_config.data_type, calibration_config.selectivity);
  return less_than_equals_(filter_column, value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_column_column(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  auto remaining_columns = generator_configuration.column_definitions;

  const auto table = generator_configuration.table;
  const auto first_column_configuration = _find_column_for_configuration(
      remaining_columns, calibration_config.data_type, calibration_config.first_encoding_type);

  remaining_columns.erase(std::remove(remaining_columns.begin(), remaining_columns.end(), first_column_configuration),
                          remaining_columns.end());

  const auto second_column_configuration = _find_column_for_configuration(
      remaining_columns, calibration_config.data_type, calibration_config.second_encoding_type);

  if (!first_column_configuration || !second_column_configuration) {
    return {};
  }

  const auto first_column = _generate_column_expression(table, *first_column_configuration);
  const auto second_column = _generate_column_expression(table, *second_column_configuration);

  return less_than_equals_(first_column, second_column);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_like(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  if (calibration_config.data_type != DataType::String) return {};

  const auto table = generator_configuration.table;
  const auto filter_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!filter_column_configuration) {
    return {};
  }

  const auto filter_column = _generate_column_expression(table, *filter_column_configuration);
  const auto value = _generate_value_expression(calibration_config.data_type, calibration_config.selectivity, true);

  return like_(filter_column, value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_equi_on_strings(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  if (calibration_config.data_type != DataType::String) return {};

  const auto table = generator_configuration.table;
  const auto filter_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!filter_column_configuration) {
    return {};
  }

  const auto filter_column = _generate_column_expression(table, *filter_column_configuration);
  const auto column_id = filter_column->column_reference.original_column_id();

  // Get an existing value from column and filter by that
  static std::mt19937 engine((std::random_device()()));
  const auto stored_table = StorageManager::get().get_table(table->table_name);
  std::uniform_int_distribution<uint64_t> row_id_dist(0, stored_table->row_count() - 1);
  const auto row_id = row_id_dist(engine);
  const auto value = stored_table->get_value<std::string>(column_id, row_id);

  return equals_(filter_column, value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_or(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  const CalibrationQueryGeneratorPredicateConfiguration second_configuration{
      calibration_config.table_name,          calibration_config.data_type,
      calibration_config.first_encoding_type, calibration_config.second_encoding_type,
      calibration_config.third_encoding_type, 0.5f,
      calibration_config.reference_column,    calibration_config.row_count};

  const auto lhs = generate_predicate_column_value(
      {generator_configuration.table, generator_configuration.column_definitions, calibration_config});
  const auto rhs = generate_predicate_column_value(
      {generator_configuration.table, generator_configuration.column_definitions, second_configuration});

  if (!lhs || !rhs) {
    return {};
  }

  return or_(lhs, rhs);
}

/**
 *
 * @param column_definitions
 * @param data_type
 * @param encoding_type
 * @return
 */
const std::optional<CalibrationColumnSpecification> CalibrationQueryGeneratorPredicate::_find_column_for_configuration(
    const std::vector<CalibrationColumnSpecification>& column_definitions, const DataType& data_type,
    const EncodingType& encoding_type) {
  for (const auto& definition : column_definitions) {
    // we don't want predicates on the primary key as they are on a different value range
    if (definition.column_name == "column_pk") continue;

    if (definition.type == data_type && definition.encoding == encoding_type) {
      return definition;
    }
  }

  return {};
}

const std::shared_ptr<LQPColumnExpression> CalibrationQueryGeneratorPredicate::_generate_column_expression(
    const std::shared_ptr<StoredTableNode>& table, const CalibrationColumnSpecification& filter_column) {
  const auto column_name = filter_column.column_name;
  const auto lqp_column_reference = table->get_column(column_name);
  return lqp_column_(lqp_column_reference);
}

const std::shared_ptr<ValueExpression> CalibrationQueryGeneratorPredicate::_generate_value_expression(
    const DataType& data_type, const float selectivity, const bool trailing_like) {
  const auto int_value_upper_limit = 10000000;

  const auto int_value = static_cast<int>(int_value_upper_limit * selectivity);
  const auto float_value = selectivity;
  const auto string_value = static_cast<int>(25 * selectivity);

  switch (data_type) {
    case DataType::Int:
    case DataType::Long:
      return value_(int_value);
    case DataType::String: {
      const auto character = std::string(1, static_cast<char>('A' + string_value));
      if (trailing_like) {
        return value_(character + '%');
      }
      return value_(character);
    }
    case DataType::Float:
    case DataType::Double:
      return value_(float_value);
    case DataType::Bool:
    case DataType::Null:
    default:
      Fail("Unsupported data type in CalibrationQueryGeneratorPredicates, found " +
           data_type_to_string.left.at(data_type));
  }
}

}  // namespace opossum
