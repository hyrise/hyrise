#include "exists_reformulation_rule.hpp"

#include <unordered_map>

#include "expression/abstract_predicate_expression.hpp"
#include "expression/binary_predicate_expression.hpp"
#include "expression/expression_functional.hpp"
#include "expression/expression_utils.hpp"
#include "expression/lqp_column_expression.hpp"
#include "expression/lqp_select_expression.hpp"
#include "expression/parameter_expression.hpp"
#include "expression/value_expression.hpp"
#include "logical_query_plan/join_node.hpp"
#include "logical_query_plan/lqp_utils.hpp"
#include "logical_query_plan/predicate_node.hpp"
#include "logical_query_plan/projection_node.hpp"

using namespace opossum::expression_functional;  // NOLINT

namespace opossum {

std::string ExistsReformulationRule::name() const { return "(Non)Exists to Join Reformulation Rule"; }

bool ExistsReformulationRule::apply_to(const std::shared_ptr<AbstractLQPNode>& node) const {
  // Find a predicate
  if (node->type != LQPNodeType::Predicate) {
    return _apply_to_inputs(node);
  }
  const auto predicate_node = std::static_pointer_cast<PredicateNode>(node);
  DebugAssert(predicate_node->predicate->type == ExpressionType::Predicate,
              "Expected predicate node to have predicate expression as predicate");

  // Check if the predicate is of the type `(EXISTS ...) == {0 or 1}` as generated by the projection
  const auto predicate_expression = std::static_pointer_cast<AbstractPredicateExpression>(predicate_node->predicate);
  if (predicate_expression->arguments[0]->type != ExpressionType::Exists) {
    return _apply_to_inputs(node);
  }

  DebugAssert(*predicate_expression->arguments[1] == ValueExpression{0},
              "Expected (NOT) EXISTS predicate to compare against 0");

  // If the predicate checks for == 0 (boolean false), we have an NOT EXISTS, otherwise an EXISTS
  const auto is_select_exists = (predicate_expression->predicate_condition != PredicateCondition::Equals);

  // Get the subselect that we work on
  const auto exists_expression = std::static_pointer_cast<ExistsExpression>(predicate_expression->arguments[0]);
  const auto subselect = std::static_pointer_cast<LQPSelectExpression>(exists_expression->select());

  // We don't care about uncorrelated subselects
  if (!subselect->is_correlated()) {
    return _apply_to_inputs(node);
  }

  // Find the projection that executes the subselect
  // We assume that the projection node is right below the predicate. This might change in the future.
  Assert(predicate_node->left_input()->type == LQPNodeType::Projection, "ProjectionNode not found");
  const auto projection_node = std::static_pointer_cast<ProjectionNode>(predicate_node->left_input());

  // First, make sure that there is only one external parameter used in the subselect's LQP
  bool found_external_parameter = false;
  for (const auto& argument : subselect->arguments) {
    if (argument->type == ExpressionType::LQPColumn) {
      if (found_external_parameter) {
        // The subselect has multiple external parameters, nothing we can do here.
        return _apply_to_inputs(node);
      }
      found_external_parameter = true;
    }
  }

  // Now make sure that the one parameter is only used once
  int uses_of_external_parameter = 0;
  visit_lqp(subselect->lqp, [&uses_of_external_parameter](const auto& deeper_node) {
    for (const auto& expression : deeper_node->node_expressions()) {
      visit_expression(expression, [&uses_of_external_parameter](const auto& subexpression) {
        if (subexpression->type == ExpressionType::Parameter) {
          auto parameter_type = std::static_pointer_cast<ParameterExpression>(subexpression)->parameter_expression_type;
          if (parameter_type == ParameterExpressionType::External) {
            ++uses_of_external_parameter;
          }
        }
        return ExpressionVisitation::VisitArguments;
      });
      if (uses_of_external_parameter > 1) {
        return LQPVisitation::DoNotVisitInputs;
      }
    }
    return LQPVisitation::VisitInputs;
  });
  if (uses_of_external_parameter > 1) {
    return _apply_to_inputs(node);
  }

  // Now go into the subselect and extract the join predicate
  auto join_predicate = std::shared_ptr<AbstractExpression>();
  auto subselect_predicate_node = std::shared_ptr<PredicateNode>();
  visit_lqp(subselect->lqp, [&join_predicate, &subselect, &subselect_predicate_node](const auto& subselect_node) {
    // Play it safe. We do not know how to handle complicated LQPs here
    if (subselect_node->type != LQPNodeType::Predicate && subselect_node->type != LQPNodeType::Validate &&
        subselect_node->type != LQPNodeType::StoredTable) {
      return LQPVisitation::DoNotVisitInputs;
    }

    // We skip over all types not excluded above
    if (subselect_node->type != LQPNodeType::Predicate) {
      return LQPVisitation::VisitInputs;
    }

    subselect_predicate_node = std::static_pointer_cast<PredicateNode>(subselect_node);
    const auto subselect_predicate_expression =
        std::static_pointer_cast<AbstractPredicateExpression>(subselect_predicate_node->predicate);

    // Semi/Anti Joins are currently only implemented by the hash join, which only supports equal predicates
    if (subselect_predicate_expression->predicate_condition != PredicateCondition::Equals) {
      return LQPVisitation::VisitInputs;
    }

    // Now check if one side of the predicate is a column "outside" the subselect and the other inside
    auto inner_column_expression = std::shared_ptr<LQPColumnExpression>();
    auto parameter_expression = std::shared_ptr<ParameterExpression>();

    if (subselect_predicate_expression->arguments[0]->type == ExpressionType::LQPColumn &&
        subselect_predicate_expression->arguments[1]->type == ExpressionType::Parameter) {
      // Column left, parameter right
      inner_column_expression =
          std::static_pointer_cast<LQPColumnExpression>(subselect_predicate_expression->arguments[0]);
      parameter_expression =
          std::static_pointer_cast<ParameterExpression>(subselect_predicate_expression->arguments[1]);
    } else if (subselect_predicate_expression->arguments[0]->type == ExpressionType::Parameter &&
               subselect_predicate_expression->arguments[1]->type == ExpressionType::LQPColumn) {
      // Column right, parameter left
      parameter_expression =
          std::static_pointer_cast<ParameterExpression>(subselect_predicate_expression->arguments[0]);
      inner_column_expression =
          std::static_pointer_cast<LQPColumnExpression>(subselect_predicate_expression->arguments[1]);
    } else {
      // It's not - let's check the next predicate
      return LQPVisitation::VisitInputs;
    }

    if (parameter_expression->parameter_expression_type != ParameterExpressionType::External) {
      // Close, but not close enough. This is a parameter of the prepared statement type
      return LQPVisitation::VisitInputs;
    }

    // Transform the parameter back into a column expression on the outside
    const auto parameter_id_iter = std::find(subselect->parameter_ids.cbegin(), subselect->parameter_ids.cend(),
                                             parameter_expression->parameter_id);
    const auto outer_column_expression =
        subselect->arguments[std::distance(subselect->parameter_ids.cbegin(), parameter_id_iter)];

    // Build the join predicate
    join_predicate = std::make_shared<BinaryPredicateExpression>(PredicateCondition::Equals, outer_column_expression,
                                                                 inner_column_expression);

    // Join predicate found, we can stop
    return LQPVisitation::DoNotVisitInputs;
  });

  if (!join_predicate) {
    // We failed to identify the join predicate or there is more than one predicate
    return _apply_to_inputs(node);
  }

  // Remove the now obsolete subselect expression from the projection
  projection_node->expressions.erase(
      std::remove_if(projection_node->expressions.begin(), projection_node->expressions.end(),
                     [&](auto& expr) { return *expr == *exists_expression; }),
      projection_node->expressions.end());

  // Remove the predicate from the subselect (because it is now handled by the join) - if it is the top level node,
  // we need to remove it by pointing the LQP to its input
  if (subselect->lqp == subselect_predicate_node) {
    subselect->lqp = subselect_predicate_node->left_input();
  } else {
    lqp_remove_node(subselect_predicate_node);
  }

  // Build the join node and put it into the LQP in the place of the predicate
  const auto join_mode = is_select_exists ? JoinMode::Semi : JoinMode::Anti;
  const auto join_node = std::make_shared<JoinNode>(join_mode, join_predicate);
  lqp_replace_node(predicate_node, join_node);
  join_node->set_right_input(subselect->lqp);

  return true;
}

}  // namespace opossum
