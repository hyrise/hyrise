#pragma once

#include <memory>

#include "optimizer/abstract_syntax_tree/abstract_ast_node.hpp"
#include "optimizer/abstract_syntax_tree/ast_types.hpp"
#include "types.hpp"

/**
 * This file contains functions that operate on AbstractSyntaxTrees, but, in order to keep the interface of
 * AbstractASTNode clean, are not part of the class.
 * This is intended for functionality that operates on the public interface of AbstractASTNode without
 * needing to know of derived node types or operates on multiple AST node types.
 */

namespace opossum {

class AbstractASTNode;

/**
 * Check whether the AST contains a Predicate or Inner Join that filters its output according to the expression
 * `descendant_a.column_id_a scan_type descendant_b.column_id_b`
 * @param column_id_a ColumnID in descendant_a
 * @param column_id_b ColumnID in descendant_b
 */
bool ast_contains_join_edge(const std::shared_ptr<const AbstractASTNode>& node,
                            const std::shared_ptr<const AbstractASTNode>& descendant_a,
                            const std::shared_ptr<const AbstractASTNode>& descendant_b, ColumnID column_id_a,
                            ColumnID column_id_b, ScanType scan_type);

/**
 * Check whether the AST contains a Predicate or Inner Join that filters its output according to the expression
 * `column_id_a scan_type column_id_b`
 * @param column_id_a, column_id_b output ColumnIDs of node
 */
bool ast_contains_join_edge(const std::shared_ptr<const AbstractASTNode>& node, ColumnID column_id_a,
                            ColumnID column_id_b, ScanType scan_type);

/**
 * Within the Columns returned by node, find the first ColumnID generated by leaf. The recursive search will walk
 * through Predicates, Sorts and Inner Joins and consider all other nodes opaque, i.e. not recurse into their children
 */
ColumnID ast_get_first_column_id_of_descendant(const std::shared_ptr<const AbstractASTNode>& node,
                                               const std::shared_ptr<const AbstractASTNode>& descendant);

/**
 * Given two shuffled sets of ColumnOrigins, determine the mapping of the indices from one (column_origins_a) into the
 * other (column_origins_b)
 */
ColumnIDMapping ast_generate_column_id_mapping(const ColumnOrigins& column_origins_a,
                                               const ColumnOrigins& column_origins_b);

}  // namespace opossum
