#pragma once

#include <cmath>
#include <memory>
#include <string>

#include "gtest/gtest.h"

#include "logical_query_plan/abstract_lqp_node.hpp"
#include "operators/abstract_operator.hpp"
#include "scheduler/operator_task.hpp"
#include "types.hpp"

namespace opossum {

class AbstractLQPNode;
class Table;

/**
 * Indicates whether the comparison of two tables should happen order sensitive (Yes) or whether it should just be
 * checked whether both tables contain the same rows, independent of order.
 */
enum class OrderSensitivity { Yes, No };

/**
 * "Strict" enforces that both tables have precisely the same column types, "Lenient" allows float instead of double, double
 * instead of float, long instead of int, int instead of long
 */
enum class TypeCmpMode { Strict, Lenient };

/**
 * When comparing tables generated by Hyrise to those generated by, e.g. SQLite, minor differences are to be expected
 * (since sqlite uses double for arithmetics, Hyrise might use float) so for large numbers
 * FloatComparisonMode::RelativeDifference is better since it allows derivation independent of the absolute value.
 * When checking against manually generated tables, FloatComparisonMode::AbsoluteDifference is the better choice.
 */
enum class FloatComparisonMode { RelativeDifference, AbsoluteDifference };

// @{
/**
 * Functions implementing the functionality of our custom macros defined at the bottom of this file.
 */

bool check_table_equal(const std::shared_ptr<const Table>& opossum_table,
                       const std::shared_ptr<const Table>& expected_table, OrderSensitivity order_sensitivity,
                       TypeCmpMode type_cmp_mode, FloatComparisonMode float_comparison_mode);

// @}

void ASSERT_INNER_JOIN_NODE(const std::shared_ptr<AbstractLQPNode>& node, PredicateCondition predicate_condition,
                            const LQPColumnReference& left_column_reference,
                            const LQPColumnReference& right_column_reference);

void ASSERT_CROSS_JOIN_NODE(const std::shared_ptr<AbstractLQPNode>& node);

bool check_lqp_tie(const std::shared_ptr<const AbstractLQPNode>& output, LQPInputSide input_side,
                   const std::shared_ptr<const AbstractLQPNode>& input);

template <typename Functor>
bool contained_in_lqp(const std::shared_ptr<AbstractLQPNode>& node, Functor contains_fn) {
  if (node == nullptr) return false;
  if (contains_fn(node)) return true;
  return contained_in_lqp(node->left_input(), contains_fn) || contained_in_lqp(node->right_input(), contains_fn);
}

template <typename Functor>
bool contained_in_query_plan(const std::shared_ptr<const AbstractOperator>& node, Functor contains_fn) {
  if (node == nullptr) return false;
  if (contains_fn(node)) return true;
  return contained_in_query_plan(node->input_left(), contains_fn) ||
         contained_in_query_plan(node->input_right(), contains_fn);
}

}  // namespace opossum

/**
 * Compare two tables with respect to OrderSensitivity, TypeCmpMode and FloatComparisonMode
 */
#define EXPECT_TABLE_EQ(opossum_table, expected_table, order_sensitivity, type_cmp_mode, float_comparison_mode) \
  EXPECT_TRUE(                                                                                                  \
      check_table_equal(opossum_table, expected_table, order_sensitivity, type_cmp_mode, float_comparison_mode));

/**
 * Specialised version of EXPECT_TABLE_EQ
 */
#define EXPECT_TABLE_EQ_UNORDERED(opossum_table, expected_table)                            \
  EXPECT_TABLE_EQ(opossum_table, expected_table, OrderSensitivity::No, TypeCmpMode::Strict, \
                  FloatComparisonMode::AbsoluteDifference)

/**
 * Specialised version of EXPECT_TABLE_EQ
 */
#define EXPECT_TABLE_EQ_ORDERED(opossum_table, expected_table)                               \
  EXPECT_TABLE_EQ(opossum_table, expected_table, OrderSensitivity::Yes, TypeCmpMode::Strict, \
                  FloatComparisonMode::AbsoluteDifference)

/**
 * Checks whether test_value differs at max `reference_value * rel_error` from reference_value.
 */
#define EXPECT_REL_NEAR(test_value, reference_value, rel_error) \
  EXPECT_NEAR(test_value, reference_value, std::fabs(reference_value* rel_error))

/**
 * Assert that a LQP `node` is a StoredTableNode referring to Table `table_name`
 */
#define ASSERT_STORED_TABLE_NODE(node, actual_table_name) \
  ASSERT_EQ(node->type(), LQPNodeType::StoredTable);      \
  ASSERT_EQ(std::dynamic_pointer_cast<const StoredTableNode>(node)->table_name(), actual_table_name);

/**
 * Assert that the `expression` is a Column Expression referring to `actual_column_id`
 */
#define ASSERT_COLUMN_EXPRESSION(expression, actual_column_reference) \
  ASSERT_EQ(expression->type(), ExpressionType::Column);              \
  ASSERT_EQ(expression->column_reference(), actual_column_reference);

/**
 * Assert that `expression` models an Aggregate Function operating on `actual_column_id`
 */
#define ASSERT_AGGREGATE_FUNCTION_EXPRESSION(expression, actual_aggregate_function, actual_column_reference) \
  ASSERT_EQ(expression->type(), ExpressionType::Function);                                                   \
  ASSERT_EQ(expression->aggregate_function(), actual_aggregate_function);                                    \
  ASSERT_EQ(expression->aggregate_function_arguments().size(), 1u);                                          \
  ASSERT_EQ(expression->aggregate_function_arguments()[0]->type(), ExpressionType::Column);                  \
  ASSERT_EQ(expression->aggregate_function_arguments()[0]->column_reference(), actual_column_reference);

#define ASSERT_LQP_TIE(output, input_side, input) \
  if (!opossum::check_lqp_tie(output, input_side, input)) FAIL();

#define EXPECT_LQP_EQ(lhs, rhs)                                  \
  {                                                              \
    const auto mismatch = lhs->find_first_subplan_mismatch(rhs); \
    if (mismatch) {                                              \
      std::cout << "Differing subtrees" << std::endl;            \
      mismatch->first->print();                                  \
      std::cout << std::endl;                                    \
      mismatch->second->print();                                 \
      std::cout << std::endl;                                    \
      GTEST_FAIL();                                              \
    }                                                            \
  }
